1.Data Level Refactorings

Replace a magic number with a named constant
Rename a variable with more informative name
Replace an expression with a method
To simplify it or avoid code duplication
Move an expression inline
Introduce an intermediate variable
Introduce explanatory variable
Convert a multi-use variable to a multiple single-use variables
Create separate variable for each usage
Create a local variable for local purposes rather than a parameter
Convert a data primitive to a class
Additional behavior / validation logic (money)
Convert a set of type codes (constants) to enum
Convert a set of type codes to a class with subclasses with different behavior
Change an array to an object
When you use an array with different types in it
Encapsulate a collection (list of cards => deck)

2.Statement Level Refactorings

Decompose a boolean expression
Move a complex boolean expression into a well-named boolean function
Consolidate duplicated code in conditionals
Return as soon as you know the answer instead of assigning a return value
Use break or return instead ofa loop control variable
Replace conditionals with polymorphism
Use null objects instead of testing for nulls

3.Method Level Refactorings

Extract method / Inline method
Rename method
Convert a long routine to a class
Add / remove parameter
Combine similar methods byparameterizing them
Substitute a complex algorithm with simpler
Separate methods whose behavior depends on parameters passed in (create new ones)
Pass a whole object rather than specific fields
Return interface types / base class

4.Class Level Refactorings

Change structure toclass and vice versa
Pull members up / pushmembers down the hierarchy
Extract specialized code into a subclass
Combine similar code into a superclass
Collapse hierarchy
Replace inheritance with delegation
Replace "is-a" with "has-a" relationship
Replace delegation with inheritance

5.Class Interface Refactorings

Extract interface(s) / Keep interface segregation
Move a method to another class
Convert a class to two
Delete a class
Hide a delegating class (A calls B and C when A should call B and B call C)
Remove the man in the middle
Introduce (use) an extension class
When we don’t have access to the original class
Alternatively use decorator pattern
Encapsulate an exposed member variable
In C# always use properties
Define proper access to getters and setters
Remove setters to read-only data
Hide data and routines that are not intended to be used outside of the class / hierarchy
private > protected > internal > public
Use strategy to avoid big class hierarchies
Apply other design patterns to solve common class and class hierarchy problems (facade, adapter, etc.)

6.System Level Refactorings

Move class (set of classes) to another namespace / assembly
Provide a factory method instead of a simple constructor / Use fluent API
Replace error codes with exceptions
Extract strings to resource files
Use dependency injection
Apply architecture patterns

